# v1.0 マイルストーンと進捗

このドキュメントは `@nenrin/*` パッケージ群の v1.0 リリースに向けたマイルストーンと現在の実装状況を追跡する.

**重要**: このドキュメントは実装作業のたびに必ず更新すること.

## v1.0 目標

v1.0 のスコープは, 次のコアパッケージを npm 公開可能な状態にすること.

* `@nenrin/types`: 型定義のみのパッケージ（type-onlyエクスポート）
* `@nenrin/core`: イベント集計と ridge anchors 生成（依存0）
* `@nenrin/geometry`: anchors から描画用点列への変換（依存0 + アルゴリズム注入）
* `@nenrin/dots`: イベントドットの座標生成（依存0 + アルゴリズム注入）

公開までの要件.

* 各パッケージのコアAPIが実装され, ビルド可能であること
* 型定義がエクスポートされ, TypeScript での利用が可能であること
* 基本的な入力バリデーションとエラーハンドリングが実装されていること
* パッケージ間の依存関係が設計通りに分離されていること（@nenrin/types のみに依存）

非目標（v1.0 以降に延期）.

* 完全なテストカバレッジ（v1.1 以降）
* 高度な曲線アルゴリズム実装（`@nenrin/geometry-algorithms-d3` は v1.1+）
* Canvas/SVG レンダラ実装（`@nenrin/renderer-canvas` は v2.0+）
* パフォーマンス最適化（v1.2+）
* プロダクション向けドキュメント整備（v1.0 で基本形, v1.1 で拡充）

## パッケージ別実装状況

### @nenrin/types (Phase 0対応中)

**ステータス**: SoA化とジェネリクス対応のため型定義を刷新中（Issue #8）

**完了した項目:**

* [x] 基本型定義の実装（`NenrinConfig`, `Domain`）
* [x] 旧AoS型の実装（`Event`, `NenrinInput`, `Ridge`, `PolarAnchor`等）※Phase 0で削除予定
* [x] ビルド設定（tsup による ESM/CJS/DTS 出力）

**残作業（Phase 0）:**

* [ ] `Event<T>` のジェネリクス化（Issue #4）
* [ ] `NenrinCoreOutput` をSoA形式へ更新（Issue #2）
    * [ ] `shape`, `sortedDomainIds`, `sortedDomainAnglesRad`, `radii` フィールドを追加
    * [ ] 旧 `Ridge`, `PolarAnchor` 型を削除
* [ ] `NenrinGeometryOutput` と `CoordinateSystemType` を追加（Issue #5）
* [ ] `DotsOutput` と `NenrinAttributeArray` を追加（Issue #7）
* [ ] 旧AoS型（`RidgePolylinePolar`, `RidgePolylineXy`, `NenrinDot`, `NenrinKnot`）を削除
* [ ] 各パッケージの関数シグネチャ型定義を追加
    * [ ] `computeNenrinCore<TMetadata>`
    * [ ] `buildRidgePolylines<TCtx>`
    * [ ] `buildDots<TMetadata>`

**備考:**

* `@nenrin/types` は type-only パッケージとして設計されている
* Issue #8 完了後, 各パッケージのAPI仕様ドキュメントも更新が必要
* Phase 0 完了後, Phase 1 (Core実装) へ移行可能

### @nenrin/core (未実装)

**ステータス**: スタブのみ（throw new Error("Not implemented")）

**完了した項目:**

* [x] パッケージ構造とビルド設定
* [x] `@nenrin/types` からの型再エクスポート

**残作業:**

* [ ] 入力バリデーション実装
    * [ ] `validateNenrinInput()`: events と config の制約チェック
    * [ ] `validateNenrinCoreOptions()`: options の制約チェック
    * [ ] エラーコード定義（`docs/ErrorPolicy.md` に従う）
        * `NENRIN_CORE_INPUT_INVALID`, `NENRIN_CORE_DOMAIN_ID_DUPLICATE`, etc.
* [ ] コア計算ロジック実装
    * [ ] domain 正規化と順序決定（`thetaRad` を $[0, 2\pi)$ に正規化, 昇順ソート）
    * [ ] domain 角度重複/近接チェック（`minDomainAngleSeparationRad`）
    * [ ] イベント集計（`activitySumPolicy: "fast" | "stable"`）
        * [ ] `(stepIndex, domainId)` でのバケット化
        * [ ] `weight` のデフォルト値 `1` 処理
        * [ ] `"stable"` モードでの重み昇順ソート
    * [ ] Ridge anchors 生成
        * [ ] 成長モデルの実装: $R(\theta, t) = R(\theta, t-1) + v_{min} + \alpha \cdot A(\theta, t)$
        * [ ] 初期条件 $R(\theta, -1) = 0$ の処理
        * [ ] 全 step `0..maxStepIndex` の dense な出力生成
* [ ] 出力構造実装
    * [ ] `NenrinCoreOutput` の構築
    * [ ] `domainIds`, `domainAnglesRad` の正規化順序での出力
    * [ ] `ridges[].anchors` の `thetaRad` 昇順保証
    * [ ] オプション出力（`activitySumByStepDomain`, `activitySumSeriesByDomainId`）
* [ ] `computeNenrinCore()` 関数の実装
* [ ] 単体テスト（最小限）
    * [ ] 正常系テスト（基本的なイベント集計と ridge 生成）
    * [ ] エラー系テスト（不正入力の検出）
    * [ ] 決定性テスト（`activitySumPolicy` の挙動確認）

**参照ドキュメント:**

* `docs/CoreApi.md`
* `docs/ErrorPolicy.md`
* `docs/concepts.md`

### @nenrin/geometry (未実装)

**ステータス**: `polarToXy()` ユーティリティのみ実装済み, メイン API は未実装

**完了した項目:**

* [x] パッケージ構造とビルド設定
* [x] `@nenrin/types` からの型再エクスポート
* [x] `polarToXy()` 関数（極座標→直交座標変換）

**残作業:**

* [ ] アルゴリズム実装
    * [ ] ベースラインアルゴリズム `linear-closed`
        * [ ] `CurveAlgorithm<undefined>` インターフェース実装
        * [ ] anchors をそのまま点列として返す（補間なし）
    * [ ] 推奨アルゴリズム `polar-linear-virtual-anchors` (実験的)
        * [ ] factory 関数 `createPolarLinearVirtualAnchorsAlgorithm(params)`
        * [ ] `NenrinCurveContext` と `baseCircle` 処理
        * [ ] virtual anchors 生成と線形補間
        * [ ] `returnStrength` によるベース円への戻し処理
* [ ] `buildRidgePolylines()` 実装
    * [ ] overload シグネチャ（`output: "polar" | "xy"` での型推論）
    * [ ] `algorithm.ridgeToPolarPolyline()` の呼び出し
    * [ ] `options.ctx` の pass-through
    * [ ] `output: "xy"` の場合の `polarToXy()` 変換
    * [ ] `validateFinite` オプション処理
* [ ] 入力バリデーション
    * [ ] `points.length < 3` のエラー処理
    * [ ] 非有限値（`NaN`, `Infinity`）の検出
    * [ ] エラーコード定義（`NENRIN_GEOMETRY_*`）
* [ ] 単体テスト（最小限）
    * [ ] `linear-closed` アルゴリズムのテスト
    * [ ] `polar` / `xy` 出力モードのテスト
    * [ ] エラー系テスト

**参照ドキュメント:**

* `docs/GeometryApi.md`
* `docs/ErrorPolicy.md`

### @nenrin/dots (未実装)

**ステータス**: スタブのみ（throw new Error("Not implemented")）

**完了した項目:**

* [x] パッケージ構造とビルド設定
* [x] `@nenrin/types` からの型再エクスポート
* [x] 独自型定義（`NenrinDot`, `NenrinKnot`, `DotsOutput`, `DotPlacementAlgorithm`, etc.）

**残作業:**

* [ ] ベースラインアルゴリズム `band-jitter` 実装
    * [ ] `DotPlacementAlgorithm` インターフェース実装
    * [ ] `buildDots(ctx)` ロジック
        * [ ] event ごとに 1 dot 生成
        * [ ] band 中心半径の計算: $\frac{R(\theta, t-1) + R(\theta, t)}{2}$
        * [ ] `t = 0` の特殊処理（$R(\theta, -1) = 0$ 想定）
        * [ ] 決定論的 jitter 生成（`eventKey` または `eventIndex` をシード化）
        * [ ] band 境界への clamp
    * [ ] knots 処理（`event.isKnot === true` の場合）
* [ ] `buildDots()` 関数実装
    * [ ] `algorithm.buildDots(ctx)` の呼び出し
    * [ ] `output: "polar" | "xy"` による座標変換
    * [ ] `bandPaddingR` オプション処理
    * [ ] `DotsOutput` 構築（`dots`, `knots?`）
* [ ] 入力バリデーション
    * [ ] `events`, `ridges` の整合性チェック
    * [ ] エラーコード定義（`NENRIN_DOTS_*`）
* [ ] 単体テスト（最小限）
    * [ ] `band-jitter` アルゴリズムのテスト
    * [ ] 決定性テスト（同一入力で同一 dots）
    * [ ] エラー系テスト

**参照ドキュメント:**

* `docs/DotsApi.md`
* `docs/ErrorPolicy.md`

## マイルストーン（フェーズ分け）

### Phase 0: 型定義の確定（最優先, ブロッカー解消）

**目標**: Issue #8 対応, `@nenrin/types` v1.0型定義の確定

**タスク:**

1. Issue #2, #4, #5, #7 の型仕様を `@nenrin/types` へ集約
2. `Event<T>` のジェネリクス化を適用（Issue #4）
3. `NenrinCoreOutput` をSoA形式へ更新（Issue #2）
4. `NenrinGeometryOutput` と `CoordinateSystemType` 定義を追加（Issue #5）
5. `DotsOutput` と `NenrinAttributeArray` をSoA形式へ追加（Issue #7）
6. 旧AoS型（`Ridge`, `PolarAnchor`, `NenrinDot`等）を削除
7. 各パッケージの関数シグネチャ型定義を追加
8. API仕様ドキュメント（`docs/CoreApi.md`, `docs/GeometryApi.md`, `docs/DotsApi.md`）を新型定義に更新

**完了条件:**

* `@nenrin/types` が Issue #2, #4, #5, #7 の型仕様をすべて含む
* 旧AoS型が削除され, SoA型のみが残る
* 各パッケージのAPI仕様ドキュメントが新型定義と一致する
* ビルドが通り, 型定義が正しくエクスポートされる

**見積もり:** 集中作業で 1-2 セッション

### Phase 1: Core 実装

**目標**: `@nenrin/core` の完全実装

**タスク:**

1. 入力バリデーションの実装
2. domain 正規化と角度処理の実装
3. イベント集計ロジックの実装（`activitySumPolicy` 対応）
4. Ridge anchors 生成の実装（成長モデル）
5. 出力構造の構築
6. 最小限のテストケース作成

**完了条件:**

* `computeNenrinCore()` が有効な入力に対して正しい `NenrinCoreOutput` を返す
* 不正な入力に対して適切なエラーコードで `Error` を throw する
* ビルドが通り, 型定義が正しくエクスポートされる

**見積もり:** 集中作業で 2-3 セッション

### Phase 2: Geometry 実装

**目標**: `@nenrin/geometry` のベースライン実装

**タスク:**

1. `linear-closed` アルゴリズムの実装
2. `buildRidgePolylines()` の実装（overload 含む）
3. `polar` / `xy` 出力モードの実装
4. 入力バリデーションとエラー処理
5. 最小限のテストケース作成

**完了条件:**

* `buildRidgePolylines()` が Core 出力を点列に変換できる
* `linear-closed` アルゴリズムが動作する
* エラーハンドリングが機能する

**見積もり:** 1-2 セッション

### Phase 3: Dots 実装

**目標**: `@nenrin/dots` のベースライン実装

**タスク:**

1. `band-jitter` アルゴリズムの実装
2. `buildDots()` の実装
3. 決定論的 jitter 生成の実装
4. band 境界の計算と clamp
5. knots 処理
6. 最小限のテストケース作成

**完了条件:**

* `buildDots()` が event から dots 座標を生成できる
* 決定性が保証される（同一入力で同一出力）
* knots が適切に分離される

**見積もり:** 1-2 セッション

### Phase 4: 統合と v1.0 リリース準備

**目標**: パッケージ間の統合確認と公開準備

**タスク:**

1. 全パッケージのビルドと型定義確認
2. パッケージ間依存の確認（`@nenrin/types` のみに依存していることを確認）
3. package.json のメタデータ整備（version, description, keywords, repository, etc.）
4. README.md の基本形作成（各パッケージ）
5. ルート README.md の作成（モノレポ全体の説明）
6. CHANGELOG.md の初版作成

**完了条件:**

* すべてのパッケージが `pnpm build` でビルド可能
* `pnpm typecheck` がエラーなく通る
* npm publish の準備が完了（dry-run 確認）

**見積もり:** 1 セッション

## 現在のステータス（2025-12-18 時点）

**完了:**

* [x] モノレポ構成の確立（pnpm workspaces）
* [x] `@nenrin/types` パッケージの完全実装
* [x] ビルドシステムの構築（tsup, TypeScript strict mode）
* [x] ドキュメント基盤の整備（`docs/*.md`）
* [x] `@nenrin/geometry` の `polarToXy()` ユーティリティ

**進行中:**

* [ ] Phase 0: 型定義の確定（Issue #8対応）
* [ ] Phase 1: Core 実装（Phase 0完了後に着手）

**ブロッカー:**

* Issue #8: `@nenrin/types`の型定義確定が必要（SoA化とジェネリクス対応）
    * Issue #2: Core出力のSoA化（`NenrinCoreOutput`の構造変更）
    * Issue #4: Core Input仕様のジェネリクス化（`Event<T>`）
    * Issue #5: Geometry APIのSoA化（`NenrinGeometryOutput`）
    * Issue #7: Dots APIのSoA化（`DotsOutput`）
* 型定義確定後、各パッケージのAPI仕様ドキュメント（`docs/CoreApi.md`等）の更新が必要

## 次のアクション

1. **Phase 0 を完了**: Issue #8 `@nenrin/types` v1.0型定義の確定（最優先）
    * Issue #2, #4, #5, #7 の型仕様を `@nenrin/types` へ集約
    * SoA化とジェネリクス対応を反映
    * 旧AoS型（`Ridge`, `PolarAnchor`, `NenrinDot`等）を削除
    * API仕様ドキュメント（`docs/CoreApi.md`等）を新型定義に更新
2. **Phase 1 を開始**: `@nenrin/core` の実装に着手（Phase 0完了後）
    * まずは入力バリデーションから実装
    * 次に domain 正規化と角度処理
    * その後イベント集計と ridge 生成（SoA形式で出力）
3. Phase 1 完了後, Phase 2 (Geometry) へ移行
4. Phase 2 完了後, Phase 3 (Dots) へ移行
5. すべての Phase 完了後, Phase 4 でリリース準備
6. （オプション）Issue #3: 可視化試験の先行実施（Phase 1-3 並行で実施可能）

## 実装時の注意事項

### 共通ガイドライン

* すべての入力バリデーションは計算前に実行する（`docs/ErrorPolicy.md` に従う）
* エラーは `code` フィールドを持つ `Error` として throw する
* 浮動小数点演算の決定性に注意（`activitySumPolicy` の選択）
* 型定義は `@nenrin/types` に集約し, 重複を避ける

### Core 実装の注意

* `vmin = 0` は許容するが, ドキュメントで非推奨とする
* `stepIndex` は連続（0..max）を前提とし, sparse な入力でも dense な出力を返す
* `anchors` の順序は必ず `thetaRad` 昇順（正規化後）

### Geometry 実装の注意

* `anchors.length < 3` の場合はエラー（閉曲線として成立しない）
* `ctx` パラメータは pass-through のみ, Geometry 自身は解釈しない
* アルゴリズムは factory パターンで注入（実行時パラメータと分離）

### Dots 実装の注意

* `eventIndex` は `events[]` 配列のインデックスとして扱う
* `t = 0` の band 内側境界は $R(\theta, -1) = 0$ として暗黙に扱う
* jitter のシード生成は `(stepIndex, domainId, eventKey | eventIndex)` で決定論的に

## 関連ドキュメント

* `docs/Policy.md`: パッケージ境界と責務分離
* `docs/CoreApi.md`: Core パッケージ API 仕様
* `docs/GeometryApi.md`: Geometry パッケージ API 仕様
* `docs/DotsApi.md`: Dots パッケージ API 仕様
* `docs/ErrorPolicy.md`: エラーハンドリング規約
* `docs/concepts.md`: 数学的概念と用語定義
* `docs/roadmap.md`: 長期ロードマップ

---

**最終更新**: 2025-12-18
